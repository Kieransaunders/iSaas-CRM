---
phase: 02-team-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/routes/api/webhooks/workos.ts
  - convex/users/sync.ts
  - convex/users/manage.ts
  - convex/users/queries.ts
autonomous: true
user_setup:
  - service: workos
    why: "Webhook signing secret needed for verifying WorkOS webhook payloads"
    env_vars:
      - name: WORKOS_WEBHOOK_SECRET
        source: "WorkOS Dashboard -> Webhooks -> Signing Secret (shown after creating webhook endpoint)"

must_haves:
  truths:
    - "WorkOS invitation.accepted webhook creates/updates user in Convex with correct role and customerId"
    - "Webhook verifies signature before processing"
    - "Admin can remove a user (soft delete - sets deletedAt)"
    - "Admin can restore a previously removed user (clears deletedAt)"
    - "Org members query returns active users filtered by role"
    - "Removed users are excluded from standard queries but available for restore"
  artifacts:
    - path: "src/routes/api/webhooks/workos.ts"
      provides: "HTTP endpoint handling WorkOS webhook events"
      contains: "invitation.accepted"
    - path: "convex/users/sync.ts"
      provides: "Internal mutation to sync user from webhook data"
      exports: ["syncFromInvitation"]
    - path: "convex/users/manage.ts"
      provides: "removeUser and restoreUser mutations"
      exports: ["removeUser", "restoreUser"]
    - path: "convex/users/queries.ts"
      provides: "listOrgMembers query with filtering"
      exports: ["listOrgMembers"]
  key_links:
    - from: "src/routes/api/webhooks/workos.ts"
      to: "convex/users/sync.ts"
      via: "Convex client mutation call from webhook handler"
      pattern: "syncFromInvitation"
    - from: "src/routes/api/webhooks/workos.ts"
      to: "WorkOS webhook verification"
      via: "Signature verification on incoming request"
      pattern: "verifyEvent|webhook.*secret"
    - from: "convex/users/manage.ts"
      to: "convex/schema.ts users.deletedAt"
      via: "Patch deletedAt field for soft delete"
      pattern: "deletedAt"
---

<objective>
Create the WorkOS webhook handler for invitation.accepted events and build user management backend (remove, restore, list members).

Purpose: The webhook is the bridge between WorkOS invitations and Convex user records. When an invited user signs up via WorkOS, the webhook syncs their data into Convex with the correct role and customer linkage. User management mutations enable the admin team page functionality.
Output: Webhook route handler, user sync mutation, user management mutations, org members query.
</objective>

<execution_context>
@/Users/boss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/boss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-team-management/02-RESEARCH.md

# Prior plan output needed for schema knowledge
@.planning/phases/02-team-management/02-01-SUMMARY.md

# Existing patterns
@convex/users/create.ts
@convex/schema.ts
@convex/workos/createOrg.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkOS webhook handler and user sync mutation</name>
  <files>src/routes/api/webhooks/workos.ts, convex/users/sync.ts</files>
  <action>
**convex/users/sync.ts** — Internal mutation for syncing user data from webhook:

Export `syncFromInvitation` as an `internalMutation`:
- Args: `{ workosUserId: v.string(), email: v.string(), firstName: v.optional(v.string()), lastName: v.optional(v.string()), orgId: v.id("orgs"), role: v.union(v.literal("staff"), v.literal("client")), customerId: v.optional(v.id("customers")) }`
- Check if user already exists by `by_workos_user_id` index
- If exists: update email, firstName, lastName, orgId, role, customerId, updatedAt
- If new: insert new user record with all fields plus createdAt and updatedAt
- Return the user ID

Export `deletePendingInvitation` as an `internalMutation`:
- Args: `{ workosInvitationId: v.string() }`
- Look up pending invitation by `by_workos_id` index
- If found, delete the record
- Return void (no error if not found — idempotent)

**src/routes/api/webhooks/workos.ts** — TanStack Start API route:

This is a server-side API route. In TanStack Start, API routes use `createAPIFileRoute`. Create the file at `src/routes/api/webhooks/workos.ts`.

The route should export a POST handler:

```typescript
import { createAPIFileRoute } from '@tanstack/react-router/server'
```

Wait -- TanStack Start API routes may use a different pattern. Check the project's existing route structure. Since there are no existing API routes, use TanStack Start's server function pattern or a catch-all API route.

IMPORTANT: TanStack Start with Convex typically handles webhooks as a standalone HTTP endpoint. The recommended approach for this stack is:

1. Create an HTTP route in Convex itself using `httpRouter`. Create `convex/http.ts`:
   - Import `httpRouter` from `convex/server`
   - Import the internal sync mutation
   - Define a POST route at `/webhooks/workos`
   - In the handler:
     a. Read the raw request body
     b. Get the `workos-signature` header
     c. Verify the webhook signature using the WorkOS SDK's `constructEvent` or manual HMAC verification
     d. Parse the event JSON
     e. If event type is `invitation.accepted`:
        - Extract invitation data: email, organizationId
        - Extract user data: id, email, firstName, lastName
        - Look up the pending invitation by workosInvitationId to get role and customerId
        - Look up the org by workosOrgId to get Convex orgId
        - Call syncFromInvitation internal mutation with all data
        - Call deletePendingInvitation internal mutation to clean up
     f. Return 200 OK response
     g. For unknown event types, return 200 (acknowledge but ignore)
   - Handle errors: return 400 for invalid signature, 500 for processing errors

ACTUALLY — Convex HTTP routes run in the Convex runtime which has limitations. The WorkOS Node SDK requires Node runtime. Better approach:

Create `convex/webhooks/workos.ts` as a Convex `httpAction` with `"use node"` directive:
- This allows using the WorkOS SDK for signature verification
- Register the route in `convex/http.ts` using httpRouter

Create `convex/http.ts`:
```typescript
import { httpRouter } from "convex/server";
import { handleWorkOSWebhook } from "./webhooks/workos";

const http = httpRouter();

http.route({
  path: "/webhooks/workos",
  method: "POST",
  handler: handleWorkOSWebhook,
});

export default http;
```

Create `convex/webhooks/workos.ts` with `"use node"` directive:
- Export `handleWorkOSWebhook` as an `httpAction`
- Import WorkOS SDK
- Read request body as text
- Get `workos-signature` header from request
- Use `workos.webhooks.constructEvent({ payload: body, sigHeader: signature, secret: process.env.WORKOS_WEBHOOK_SECRET })` to verify and parse
- Handle `invitation.accepted` event:
  - Look up pending invitation by workosInvitationId (using an internal query)
  - Look up org by workosOrgId (using internal query `getOrgByWorkosId`)
  - Call syncFromInvitation with extracted data
  - Call deletePendingInvitation to clean up
- Return `new Response("OK", { status: 200 })`
- On verification failure: return `new Response("Invalid signature", { status: 400 })`

Also create a helper internal query in `convex/invitations/queries.ts` (or a new internal file):
- `getByWorkosId` internal query to look up pending invitation by workosInvitationId

And add an internal query to `convex/orgs/get.ts`:
- `getOrgByWorkosOrgId` internal query to look up org by workosOrgId

NOTE: If `convex/orgs/get.ts` already has `getMyOrgInternal`, add the new internal query to the same file. Read it first.
  </action>
  <verify>Run `npx convex dev --once` to verify http router and all functions compile. Grep for "invitation.accepted" in webhook handler. Grep for "syncFromInvitation" export. Grep for "httpRouter" in convex/http.ts. Verify `npx tsc --noEmit` passes.</verify>
  <done>Webhook handler registered at /webhooks/workos via Convex httpRouter. Handler verifies WorkOS signature, processes invitation.accepted events, syncs user data to Convex with correct role/customerId, deletes pending invitation record. All compile.</done>
</task>

<task type="auto">
  <name>Task 2: Create user management mutations and org members query</name>
  <files>convex/users/manage.ts, convex/users/queries.ts</files>
  <action>
**convex/users/manage.ts** — Convex mutations:

Export `removeUser` mutation:
- Args: `{ userId: v.id("users") }`
- Auth check: get user identity, look up user record, verify role is "admin"
- Look up the target user by _id
- Verify target user belongs to same org as admin
- Prevent admin from removing themselves (throw ConvexError "Cannot remove yourself")
- Set `deletedAt: Date.now()` on the target user via `ctx.db.patch`
- Auto-unassign: query staffCustomerAssignments by `by_staff` index for this user, delete all assignments (following the research recommendation for auto-unassign on removal)
- Return `{ success: true }`

Export `restoreUser` mutation:
- Args: `{ userId: v.id("users") }`
- Auth check: admin only, same org
- Look up the target user
- Verify `deletedAt` is set (throw ConvexError "User is not removed" if already active)
- Clear `deletedAt` by patching to `undefined`
- Update `updatedAt` to Date.now()
- Return `{ success: true }`

**convex/users/queries.ts** — Convex queries:

Export `listOrgMembers` query:
- No args (uses auth context)
- Auth check: get user identity, look up user record, verify has orgId
- Only admin can list all members (throw ConvexError "Permission denied" for non-admin)
- Query users table by `by_org` index for user's orgId
- Return all users (including those with deletedAt set — admin needs to see removed users for restore)
- For each user, include a computed `status` field:
  - If `deletedAt` is set: status = "removed"
  - Else: status = "active"
- Also include `displayName`: firstName + lastName, or email as fallback
- Sort: active users first, then removed users

Export `getOrgMemberCounts` query:
- No args (uses auth context)
- Auth check, get orgId
- Count users by role (staff, client) — only active (no deletedAt)
- Count pending invitations by role
- Return `{ staffCount, clientCount, pendingCount, totalActive }`
  </action>
  <verify>Run `npx convex dev --once` to verify all functions compile. Grep for exports: `removeUser`, `restoreUser`, `listOrgMembers`, `getOrgMemberCounts`. Verify `npx tsc --noEmit` passes.</verify>
  <done>removeUser soft-deletes user and auto-unassigns staff assignments. restoreUser clears deletedAt. listOrgMembers returns all org users with status field. getOrgMemberCounts returns role-based counts. All compile.</done>
</task>

</tasks>

<verification>
- `npx convex dev --once` passes (all functions + http router compile)
- `npx tsc --noEmit` passes
- Webhook handler verifies signature and processes invitation.accepted
- syncFromInvitation creates/updates user with correct role and customerId
- Pending invitation is deleted after successful sync
- removeUser sets deletedAt and auto-unassigns staff
- restoreUser clears deletedAt
- listOrgMembers returns users with status field (active/removed)
- getOrgMemberCounts returns per-role counts
</verification>

<success_criteria>
- WorkOS webhook endpoint registered at /webhooks/workos in Convex httpRouter
- Webhook verifies signature using WORKOS_WEBHOOK_SECRET
- invitation.accepted event creates user with correct role and customer linkage
- Pending invitation cleaned up after acceptance
- Admin can soft-delete users (sets deletedAt, removes staff assignments)
- Admin can restore soft-deleted users
- Org members query returns all users with active/removed status
- Member counts query provides data for team page tabs
</success_criteria>

<output>
After completion, create `.planning/phases/02-team-management/02-03-SUMMARY.md`
</output>
