---
phase: 03-billing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/http.ts
  - convex/lemonsqueezy/webhook.ts
  - convex/lemonsqueezy/signature.ts
  - convex/lemonsqueezy/sync.ts
  - convex/lemonsqueezy/plans.ts
autonomous: true
user_setup:
  - service: lemonsqueezy
    why: "Subscription billing provider"
    env_vars:
      - name: LEMONSQUEEZY_WEBHOOK_SECRET
        source: "Lemon Squeezy Dashboard -> Settings -> Webhooks -> Signing secret"
    dashboard_config:
      - task: "Create webhook endpoint pointing to your Convex HTTP action URL"
        location: "Lemon Squeezy Dashboard -> Settings -> Webhooks -> Add endpoint"

must_haves:
  truths:
    - "Webhook endpoint at /lemonsqueezy/webhook accepts POST requests"
    - "Invalid webhook signatures are rejected with 401"
    - "Org subscription status reflects Lemon Squeezy state after webhook events"
    - "Cancelled subscriptions marked immediately in database with access until period end"
    - "Expired subscriptions revert org to free tier limits"
    - "Trial subscriptions store trial_ends_at for UI display"
    - "Variant ID to plan limits mapping is centralized in one file"
  artifacts:
    - path: "convex/http.ts"
      provides: "HTTP router with Lemon Squeezy webhook route"
      contains: "/lemonsqueezy/webhook"
    - path: "convex/lemonsqueezy/webhook.ts"
      provides: "httpAction handler for webhook events"
      exports: ["handleWebhook"]
    - path: "convex/lemonsqueezy/signature.ts"
      provides: "HMAC-SHA256 signature verification using Web Crypto API"
      exports: ["verifySignature"]
    - path: "convex/lemonsqueezy/sync.ts"
      provides: "Internal mutations to update org subscription state"
      exports: ["processSubscriptionEvent"]
    - path: "convex/lemonsqueezy/plans.ts"
      provides: "Plan tier definitions with limits mapping"
      exports: ["PLAN_TIERS", "getLimitsForVariant", "FREE_TIER_LIMITS"]
  key_links:
    - from: "convex/http.ts"
      to: "convex/lemonsqueezy/webhook.ts"
      via: "route handler import"
      pattern: "handleWebhook"
    - from: "convex/lemonsqueezy/webhook.ts"
      to: "convex/lemonsqueezy/signature.ts"
      via: "signature verification before processing"
      pattern: "verifySignature"
    - from: "convex/lemonsqueezy/webhook.ts"
      to: "convex/lemonsqueezy/sync.ts"
      via: "internal mutation call"
      pattern: "ctx.runMutation.*processSubscriptionEvent"
    - from: "convex/lemonsqueezy/sync.ts"
      to: "convex/lemonsqueezy/plans.ts"
      via: "plan limits lookup"
      pattern: "getLimitsForVariant"
---

<objective>
Build the Lemon Squeezy webhook infrastructure: HTTP endpoint, signature verification, and subscription state sync to Convex.

Purpose: This is the backbone of billing -- all subscription lifecycle events flow through the webhook handler to keep org billing state in sync. Without this, no checkout or plan change can update the database.

Output: Working webhook endpoint that receives Lemon Squeezy events, verifies signatures, and updates org subscription status and plan caps via internal mutations.
</objective>

<execution_context>
@/Users/boss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/boss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-billing/03-RESEARCH.md

Key existing code to reference:
@convex/schema.ts (org table has subscriptionId, subscriptionStatus, planId, maxCustomers, maxStaff, maxClients)
@convex/invitations/internal.ts (pattern for internalMutation/internalQuery)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plan tier config and signature verification helper</name>
  <files>
    convex/lemonsqueezy/plans.ts
    convex/lemonsqueezy/signature.ts
  </files>
  <action>
Create `convex/lemonsqueezy/plans.ts`:
- Define a `PLAN_TIERS` constant object mapping variant IDs to plan details. Use placeholder variant IDs (strings like "VARIANT_PRO", "VARIANT_BUSINESS") that will be replaced with real Lemon Squeezy variant IDs when the user sets up their store.
- Plan tiers (user decision: 3 tiers, Free/Pro/Business):
  - Free: maxCustomers: 3, maxStaff: 2, maxClients: 10 (existing defaults)
  - Pro: maxCustomers: 25, maxStaff: 10, maxClients: 100
  - Business: maxCustomers: 100, maxStaff: 50, maxClients: 500
- Export `FREE_TIER_LIMITS` constant with the free tier values
- Export `getLimitsForVariant(variantId: string)` function that returns the limits for a variant ID, defaulting to FREE_TIER_LIMITS if unknown
- Export `getPlanName(variantId: string | undefined)` that returns "Free", "Pro", or "Business"
- Include clear comments that variant IDs must be updated with real values from Lemon Squeezy dashboard

Create `convex/lemonsqueezy/signature.ts`:
- Export `verifySignature(signature: string, body: string, secret: string): Promise<boolean>`
- Use Web Crypto API (NOT Node.js crypto -- Convex runtime doesn't support it)
- Import the secret key with `crypto.subtle.importKey("raw", ...)` using HMAC SHA-256
- Sign the body with `crypto.subtle.sign("HMAC", key, encodedBody)`
- Convert digest to hex string
- Compare hex digest against provided signature string
- Use TextEncoder for encoding (standard Web API)
  </action>
  <verify>
Run `npx convex dev --once` to verify the files compile. Check that neither file imports from Node.js crypto module. Verify `getLimitsForVariant` returns correct limits for each tier and defaults to free for unknown variants.
  </verify>
  <done>
Plans config exports FREE_TIER_LIMITS, PLAN_TIERS, getLimitsForVariant, getPlanName. Signature verification uses Web Crypto API only (no Node.js crypto). Both files compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook handler and subscription sync</name>
  <files>
    convex/lemonsqueezy/webhook.ts
    convex/lemonsqueezy/sync.ts
    convex/http.ts
  </files>
  <action>
Create `convex/lemonsqueezy/sync.ts`:
- Import `internalMutation` from `../_generated/server` and `v` from `convex/values`
- Import `getLimitsForVariant` and `FREE_TIER_LIMITS` from `./plans`
- Export `processSubscriptionEvent` as an `internalMutation` with args:
  - `eventName: v.string()` -- the webhook event name
  - `customerId: v.optional(v.string())` -- Lemon Squeezy customer_id from subscription attributes (stored as lemonSqueezyCustomerId on org for customer portal URL retrieval)
  - `subscriptionId: v.string()` -- LS subscription ID
  - `variantId: v.string()` -- LS variant ID for plan lookup
  - `status: v.string()` -- LS subscription status
  - `orgConvexId: v.optional(v.string())` -- org Convex ID from custom data (checkout[custom][org_convex_id])
  - `trialEndsAt: v.optional(v.string())` -- ISO date string from subscription attributes.trial_ends_at (null if not a trial)
  - `endsAt: v.optional(v.string())` -- ISO date string from subscription attributes.ends_at (set on cancellation)
- Handler logic:
  1. Find org: Try `orgConvexId` first (from checkout custom data via meta.custom_data), then fall back to finding org by existing `subscriptionId` field matching the subscription ID
  2. If no org found, log warning and return (webhook for unknown org)
  3. For `subscription_created` and `subscription_updated`: update org with subscriptionId, subscriptionStatus mapped to schema union (map LS status string to "active"/"cancelled"/"past_due"/"unpaid"/"paused"), planId (variant ID), lemonSqueezyCustomerId (from customerId arg), and plan limits from `getLimitsForVariant(variantId)`, plus updatedAt. **Trial handling:** If subscription attributes include `trial_ends_at` (non-null), store it as `trialEndsAt: new Date(attributes.trial_ends_at).getTime()` on the org. This enables the billing UI to show "Trial ends in X days". If `trial_ends_at` is null, set `trialEndsAt: undefined` to clear any previous trial state.
  4. For `subscription_cancelled`: set subscriptionStatus to "cancelled", keep current plan limits (user has access until period ends -- per LS grace period behavior), store `endsAt` from subscription attributes if available, update updatedAt
  5. For `subscription_expired`: set subscriptionStatus to "inactive", reset to FREE_TIER_LIMITS (maxCustomers, maxStaff, maxClients), clear planId, subscriptionId, trialEndsAt, and endsAt, update updatedAt. **This handles both trial expiration (14-day trial ends without payment) and regular subscription expiration.**
  6. For `subscription_payment_failed`: set subscriptionStatus to "past_due", keep limits (LS retries payment), update updatedAt

Create `convex/lemonsqueezy/webhook.ts`:
- Import `httpAction` from `../_generated/server` and `internal` from `../_generated/api`
- Import `verifySignature` from `./signature`
- Export `handleWebhook` as an `httpAction`:
  1. Read raw body with `request.text()` -- IMPORTANT: do NOT use `request.json()` first, it consumes the body and breaks signature verification
  2. Get `X-Signature` header from request
  3. If no signature, return `new Response("Missing signature", { status: 401 })`
  4. Get webhook secret from `process.env.LEMONSQUEEZY_WEBHOOK_SECRET`
  5. If no secret configured, log error and return 500
  6. Verify signature. If invalid, return `new Response("Invalid signature", { status: 401 })`
  7. Parse body with `JSON.parse(rawBody)`
  8. Extract `eventName` from `payload.meta.event_name`
  9. Extract `customData` from `payload.meta.custom_data` (contains org_convex_id from checkout)
  10. Only process events starting with "subscription_": extract `trial_ends_at` and `ends_at` from `payload.data.attributes` (may be null). Call `ctx.runMutation(internal.lemonsqueezy.sync.processSubscriptionEvent, { ... })` with all extracted fields including `trialEndsAt` and `endsAt`
  11. Always return `new Response(null, { status: 200 })` -- even for unhandled events (prevents LS retries)

Create `convex/http.ts`:
- Import `httpRouter` from `convex/server`
- Import `handleWebhook` from `./lemonsqueezy/webhook`
- Create router with `httpRouter()`
- Register route: `path: "/lemonsqueezy/webhook"`, `method: "POST"`, `handler: handleWebhook`
- Export default the router
  </action>
  <verify>
Run `npx convex dev --once` to verify all files compile. Check that:
1. http.ts exports a default httpRouter
2. webhook.ts reads body as text before JSON parse
3. sync.ts handles all 5 event types (created, updated, cancelled, expired, payment_failed) and stores trialEndsAt/endsAt when present
4. No imports from Node.js-specific modules
  </verify>
  <done>
Webhook endpoint registered at `/lemonsqueezy/webhook`. Handler verifies signature before processing, parses event, and delegates to sync mutation. Sync mutation updates org subscription status and plan caps based on event type. All subscription lifecycle events handled: created, updated, cancelled, expired, payment_failed.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` succeeds without errors
2. convex/http.ts exists and routes POST /lemonsqueezy/webhook
3. Signature verification uses Web Crypto API (grep for `crypto.subtle`)
4. No Node.js crypto imports (grep for `require("crypto")` or `import crypto`)
5. Plans config has all 3 tiers with correct limits
6. Sync mutation handles subscription_created, subscription_updated, subscription_cancelled, subscription_expired, subscription_payment_failed
</verification>

<success_criteria>
- Webhook infrastructure compiles and deploys to Convex
- Plan tier config is centralized with clear placeholder variant IDs
- Signature verification uses Web Crypto API (Convex-compatible)
- All subscription lifecycle events update org state correctly
- Free tier downgrade resets limits; cancellation preserves limits until expiry
- Trial subscriptions store trialEndsAt timestamp; expired trials downgrade to free tier
</success_criteria>

<output>
After completion, create `.planning/phases/03-billing/03-01-SUMMARY.md`
</output>
