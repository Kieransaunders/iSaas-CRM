---
description: Convex backend patterns - queries, mutations, schema design, and best practices
globs: convex/**/*.ts
alwaysApply: true
---

# 2. Convex Patterns and Guidelines

This document covers Convex backend development patterns, schema design, and best practices for iSaaSIT.

## Function Syntax

### ALWAYS Use New Function Syntax

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQuery = query({
    args: { name: v.string() },
    returns: v.string(),
    handler: async (ctx, args) => {
        return "Hello " + args.name;
    },
});
```

### Function Types Reference

| Function Type | Import From | Visibility | Use Case |
|--------------|-------------|------------|----------|
| `query` | `./_generated/server` | Public | Read operations (client callable) |
| `mutation` | `./_generated/server` | Public | Write operations (client callable) |
| `action` | `./_generated/server` | Public | Side effects, external APIs (client callable) |
| `internalQuery` | `./_generated/server` | Private | Internal reads (Convex functions only) |
| `internalMutation` | `./_generated/server` | Private | Internal writes (Convex functions only) |
| `internalAction` | `./_generated/server` | Private | Internal side effects (Convex functions only) |
| `httpAction` | `./_generated/server` | HTTP endpoint | Webhooks, custom HTTP routes |

### HTTP Endpoints

Define in `convex/http.ts`:

```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
    path: "/webhook/lemon-squeezy",
    method: "POST",
    handler: httpAction(async (ctx, req) => {
        const body = await req.json();
        // Process webhook
        return new Response("OK", { status: 200 });
    }),
});

export default http;
```

## Schema Design

### File Location
Always define schema in `convex/schema.ts`:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    orgs: defineTable({
        workOsOrgId: v.string(),
        subscriptionId: v.optional(v.string()),
        planId: v.optional(v.string()),
        maxCustomers: v.number(),
        maxStaff: v.number(),
        maxClients: v.number(),
    })
        .index("by_workos_org", ["workOsOrgId"])
        .index("by_subscription", ["subscriptionId"]),

    customers: defineTable({
        orgId: v.id("orgs"),
        name: v.string(),
        email: v.optional(v.string()),
    })
        .index("by_org", ["orgId"])
        .index("by_org_name", ["orgId", "name"]),

    staffCustomerAssignments: defineTable({
        userId: v.string(), // WorkOS user ID
        customerId: v.id("customers"),
        orgId: v.id("orgs"),
    })
        .index("by_user", ["userId"])
        .index("by_customer", ["customerId"])
        .index("by_org_user", ["orgId", "userId"]),
});
```

### Index Naming Rules
- Always include all index fields in the name
- Use `by_field1` for single field, `by_field1_and_field2` for multiple
- Index order matters - query in the same order they are defined

### System Fields
All documents automatically include:
- `_id` - Document ID (`v.id(tableName)`)
- `_creationTime` - Timestamp in milliseconds (`v.number()`)

## Validators Reference

| Convex Type | TypeScript Type | Validator | Notes |
|-------------|-----------------|-----------|-------|
| Id | string | `v.id("tableName")` | Document reference |
| Null | null | `v.null()` | Use instead of undefined |
| Int64 | bigint | `v.int64()` | Signed 64-bit integer |
| Float64 | number | `v.number()` | IEEE-754 double precision |
| Boolean | boolean | `v.boolean()` | |
| String | string | `v.string()` | UTF-8, <1MB |
| Bytes | ArrayBuffer | `v.bytes()` | Binary data, <1MB |
| Array | Array | `v.array(v.string())` | Max 8192 items |
| Object | Object | `v.object({...})` | Plain objects, max 1024 keys |
| Record | Record | `v.record(keys, values)` | Dynamic keys |
| Union | Union | `v.union(v.string(), v.number())` | Discriminated unions |
| Literal | Literal | `v.literal("value")` | Specific values |
| Optional | Optional | `v.optional(v.string())` | Nullable fields |

## Query Patterns

### Basic Query

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getCustomers = query({
    args: { orgId: v.id("orgs") },
    returns: v.array(v.any()), // Or specific validator
    handler: async (ctx, args) => {
        return await ctx.db
            .query("customers")
            .withIndex("by_org", (q) => q.eq("orgId", args.orgId))
            .order("desc")
            .take(100);
    },
});
```

### Pagination

```typescript
import { paginationOptsValidator } from "convex/server";

export const listCustomers = query({
    args: { 
        orgId: v.id("orgs"),
        paginationOpts: paginationOptsValidator 
    },
    handler: async (ctx, args) => {
        return await ctx.db
            .query("customers")
            .withIndex("by_org", (q) => q.eq("orgId", args.orgId))
            .order("desc")
            .paginate(args.paginationOpts);
    },
});
```

Returns:
- `page` - Array of documents
- `isDone` - Boolean indicating if last page
- `continueCursor` - Cursor for next page

### Single Document Lookup

```typescript
export const getCustomer = query({
    args: { customerId: v.id("customers") },
    handler: async (ctx, args) => {
        return await ctx.db.get(args.customerId);
    },
});
```

### Query with Filter (Using Index)

```typescript
// GOOD: Uses index
export const getActiveCustomers = query({
    args: { orgId: v.id("orgs") },
    handler: async (ctx, args) => {
        return await ctx.db
            .query("customers")
            .withIndex("by_org_status", (q) => 
                q.eq("orgId", args.orgId).eq("status", "active")
            )
            .collect();
    },
});

// BAD: Don't use .filter() - define an index instead
```

## Mutation Patterns

### Insert

```typescript
import { mutation } from "./_generated/server";

export const createCustomer = mutation({
    args: {
        orgId: v.id("orgs"),
        name: v.string(),
        email: v.optional(v.string()),
    },
    returns: v.id("customers"),
    handler: async (ctx, args) => {
        return await ctx.db.insert("customers", {
            orgId: args.orgId,
            name: args.name,
            email: args.email,
        });
    },
});
```

### Update (Patch)

```typescript
export const updateCustomer = mutation({
    args: {
        customerId: v.id("customers"),
        updates: v.object({
            name: v.optional(v.string()),
            email: v.optional(v.string()),
        }),
    },
    handler: async (ctx, args) => {
        await ctx.db.patch(args.customerId, args.updates);
        return await ctx.db.get(args.customerId);
    },
});
```

### Replace (Full Document)

```typescript
export const replaceCustomer = mutation({
    args: {
        customerId: v.id("customers"),
        data: v.object({
            orgId: v.id("orgs"),
            name: v.string(),
            email: v.optional(v.string()),
        }),
    },
    handler: async (ctx, args) => {
        return await ctx.db.replace(args.customerId, args.data);
    },
});
```

### Delete

```typescript
export const deleteCustomer = mutation({
    args: { customerId: v.id("customers") },
    returns: v.null(),
    handler: async (ctx, args) => {
        await ctx.db.delete(args.customerId);
        return null;
    },
});
```

### Bulk Delete (No .delete() on queries)

```typescript
// GOOD: Collect then delete
export const deleteInactiveCustomers = mutation({
    args: { orgId: v.id("orgs") },
    handler: async (ctx, args) => {
        const inactive = await ctx.db
            .query("customers")
            .withIndex("by_org_status", (q) => 
                q.eq("orgId", args.orgId).eq("status", "inactive")
            )
            .collect();
        
        for (const customer of inactive) {
            await ctx.db.delete(customer._id);
        }
    },
});
```

## Function Calling Patterns

### Calling Functions Within Convex

```typescript
import { api, internal } from "./_generated/api";

export const myMutation = mutation({
    args: { orgId: v.id("orgs") },
    handler: async (ctx, args) => {
        // Call another query
        const count: number = await ctx.runQuery(
            api.customers.countCustomers, 
            { orgId: args.orgId }
        );
        
        // Call an internal action
        await ctx.runAction(
            internal.billing.syncSubscription,
            { orgId: args.orgId }
        );
        
        // Call an internal mutation
        await ctx.runMutation(
            internal.audit.logAction,
            { orgId: args.orgId, action: "count_check" }
        );
    },
});
```

### Type Annotations for Same-File Calls

When calling functions in the same file, add return type annotations to avoid TypeScript circularity issues:

```typescript
export const getCount = query({
    args: {},
    returns: v.number(),
    handler: async (ctx) => {
        return 42;
    },
});

export const useCount = query({
    args: {},
    handler: async (ctx) => {
        // Add type annotation
        const count: number = await ctx.runQuery(api.example.getCount, {});
        return count;
    },
});
```

## TypeScript Guidelines

### Import Types

```typescript
// Document ID types
import { Id } from "./_generated/dataModel";

// Entity types
import type { Doc } from "./_generated/dataModel";
type Customer = Doc<"customers">;

// Strict ID typing
function doSomething(userId: Id<"users">) { ... } // NOT just string
```

### Discriminated Unions

```typescript
const statusValidator = v.union(
    v.object({ kind: v.literal("active") }),
    v.object({ kind: v.literal("inactive"), reason: v.string() }),
);

// Use 'as const' for string literals
type Status = 
    | { kind: "active" }
    | { kind: "inactive"; reason: string };
```

## Action Guidelines

### Node.js Built-ins

Add `"use node";` at the top for Node.js modules:

```typescript
"use node";

import { action } from "./_generated/server";
import fs from "fs";

export const processFile = action({
    args: { path: v.string() },
    handler: async (ctx, args) => {
        // Can use Node.js APIs here
        const content = await fs.promises.readFile(args.path);
        return content.toString();
    },
});
```

### No Database Access in Actions

Actions cannot use `ctx.db`. Use queries/mutations instead:

```typescript
export const syncData = action({
    args: { orgId: v.id("orgs") },
    handler: async (ctx, args) => {
        // ❌ Can't do: ctx.db.get(...)
        
        // ✅ Call a query instead
        const org = await ctx.runQuery(internal.orgs.getOrg, {
            orgId: args.orgId,
        });
        
        // Do external API call
        const data = await fetchExternalData(org.externalId);
        
        // Save via mutation
        await ctx.runMutation(internal.orgs.updateSyncData, {
            orgId: args.orgId,
            data,
        });
    },
});
```

## Scheduling

### Cron Jobs

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";
import { internalAction } from "./_generated/server";

const checkSubscriptions = internalAction({
    args: {},
    handler: async (ctx) => {
        // Check all subscriptions
    },
});

const crons = cronJobs();

// Run every hour
crons.interval(
    "check subscriptions",
    { hours: 1 },
    internal.crons.checkSubscriptions,
    {}
);

// Run at specific time (UTC)
crons.cron(
    "daily report",
    "0 9 * * *", // 9 AM daily
    internal.crons.sendDailyReport,
    {}
);

export default crons;
```

### Scheduling from Functions

```typescript
export const scheduleReminder = mutation({
    args: { 
        customerId: v.id("customers"),
        delayMinutes: v.number(),
    },
    handler: async (ctx, args) => {
        await ctx.scheduler.runAfter(
            args.delayMinutes * 60 * 1000,
            internal.notifications.sendReminder,
            { customerId: args.customerId }
        );
    },
});
```

## File Storage

### Getting File URLs

```typescript
export const getFileUrl = query({
    args: { fileId: v.id("_storage") },
    returns: v.union(v.string(), v.null()),
    handler: async (ctx, args) => {
        return await ctx.storage.getUrl(args.fileId);
    },
});
```

### File Metadata

Query the `_storage` system table:

```typescript
export const getFileMetadata = query({
    args: { fileId: v.id("_storage") },
    handler: async (ctx, args) => {
        return await ctx.db.system.get("_storage", args.fileId);
    },
});
```

## Common Patterns for iSaaSIT

### Org-Scoped Query

```typescript
export const getOrgCustomers = query({
    args: { orgId: v.id("orgs") },
    handler: async (ctx, args) => {
        // Verify user has access to this org via WorkOS context
        // This is handled by auth, but can add extra checks
        return await ctx.db
            .query("customers")
            .withIndex("by_org", (q) => q.eq("orgId", args.orgId))
            .collect();
    },
});
```

### Staff-Scoped Query (with assignments)

```typescript
export const getAssignedCustomers = query({
    args: { userId: v.string() },
    handler: async (ctx, args) => {
        const assignments = await ctx.db
            .query("staffCustomerAssignments")
            .withIndex("by_user", (q) => q.eq("userId", args.userId))
            .collect();
        
        const customers = [];
        for (const assignment of assignments) {
            const customer = await ctx.db.get(assignment.customerId);
            if (customer) customers.push(customer);
        }
        return customers;
    },
});
```

### Usage Cap Check

```typescript
export const createCustomerWithCap = mutation({
    args: {
        orgId: v.id("orgs"),
        name: v.string(),
    },
    handler: async (ctx, args) => {
        const org = await ctx.db.get(args.orgId);
        if (!org) throw new Error("Org not found");
        
        const count = await ctx.db
            .query("customers")
            .withIndex("by_org", (q) => q.eq("orgId", args.orgId))
            .collect();
        
        if (count.length >= org.maxCustomers) {
            throw new Error("Customer limit reached for this plan");
        }
        
        return await ctx.db.insert("customers", {
            orgId: args.orgId,
            name: args.name,
        });
    },
});
```
