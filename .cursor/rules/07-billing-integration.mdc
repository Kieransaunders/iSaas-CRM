---
description: Lemon Squeezy billing patterns - subscriptions, usage caps, webhooks
globs: convex/**/*.ts
alwaysApply: true
---

# 7. Billing Integration (Lemon Squeezy)

This document covers Lemon Squeezy billing integration, subscription management, and usage cap enforcement for iSaaSIT.

## Overview

- **Provider**: Lemon Squeezy (Merchant of Record for global sales)
- **Billing Level**: Organization (not individual users)
- **Model**: Freemium with usage caps
- **Caps**: maxCustomers, maxStaff, maxClients synced from plan metadata

## Schema

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    orgs: defineTable({
        workOsOrgId: v.string(),
        name: v.string(),
        
        // Billing fields
        subscriptionId: v.optional(v.string()),
        planId: v.optional(v.string()),
        status: v.union(
            v.literal("active"),
            v.literal("trialing"),
            v.literal("past_due"),
            v.literal("canceled"),
            v.literal("unpaid")
        ),
        
        // Usage caps (synced from plan)
        maxCustomers: v.number(),
        maxStaff: v.number(),
        maxClients: v.number(),
        
        // Billing dates
        trialEndsAt: v.optional(v.number()),
        currentPeriodStart: v.optional(v.number()),
        currentPeriodEnd: v.optional(v.number()),
        
        // Timestamps
        updatedAt: v.number(),
    })
        .index("by_workos_org", ["workOsOrgId"])
        .index("by_subscription", ["subscriptionId"]),
    
    // Usage tracking (optional, for analytics)
    usageEvents: defineTable({
        orgId: v.id("orgs"),
        type: v.union(
            v.literal("customer_created"),
            v.literal("staff_invited"),
            v.literal("client_invited")
        ),
        timestamp: v.number(),
    }).index("by_org", ["orgId"]),
});
```

## Plan Configuration

### Lemon Squeezy Product Setup

Create variants in Lemon Squeezy with metadata:

```json
{
    "maxCustomers": 10,
    "maxStaff": 5,
    "maxClients": 50
}
```

### Plan Tiers (Example)

| Plan | maxCustomers | maxStaff | maxClients | Price |
|------|-------------|----------|------------|-------|
| Free | 3 | 1 | 10 | $0 |
| Starter | 10 | 3 | 50 | $29/mo |
| Pro | 50 | 10 | 200 | $79/mo |
| Enterprise | ∞ | ∞ | ∞ | $199/mo |

## Checkout Flow

### Create Checkout Session

```typescript
// convex/billing.ts
import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

export const createCheckout = action({
    args: {
        orgId: v.id("orgs"),
        variantId: v.string(), // Lemon Squeezy variant ID
    },
    handler: async (ctx, args) => {
        const org = await ctx.runQuery(internal.orgs.get, { orgId: args.orgId });
        if (!org) throw new Error("Organization not found");
        
        // Call Lemon Squeezy API to create checkout
        const response = await fetch(
            "https://api.lemonsqueezy.com/v1/checkouts",
            {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${process.env.LEMON_SQUEEZY_API_KEY}`,
                    "Content-Type": "application/json",
                    "Accept": "application/vnd.api+json",
                },
                body: JSON.stringify({
                    data: {
                        type: "checkouts",
                        attributes: {
                            product_options: {
                                enabled_variants: [args.variantId],
                            },
                            checkout_options: {
                                embed: false,
                                media: true,
                                logo: true,
                            },
                            checkout_data: {
                                custom: {
                                    org_id: args.orgId,
                                },
                            },
                        },
                        relationships: {
                            store: {
                                data: {
                                    type: "stores",
                                    id: process.env.LEMON_SQUEEZY_STORE_ID,
                                },
                            },
                            variant: {
                                data: {
                                    type: "variants",
                                    id: args.variantId,
                                },
                            },
                        },
                    },
                }),
            }
        );
        
        if (!response.ok) {
            throw new Error("Failed to create checkout");
        }
        
        const { data } = await response.json();
        return {
            checkoutUrl: data.attributes.url,
            checkoutId: data.id,
        };
    },
});
```

### Frontend Checkout Button

```typescript
// src/features/billing/upgrade-button.tsx
import { useState } from "react";
import { useAction } from "@convex-dev/react-query";
import { api } from "@/convex/_generated/api";

const PLAN_VARIANTS = {
    starter: "123456",  // Lemon Squeezy variant IDs
    pro: "789012",
    enterprise: "345678",
};

export function UpgradeButton({ plan }: { plan: keyof typeof PLAN_VARIANTS }) {
    const [isLoading, setIsLoading] = useState(false);
    const createCheckout = useAction(api.billing.createCheckout);
    
    const handleUpgrade = async () => {
        setIsLoading(true);
        try {
            const { checkoutUrl } = await createCheckout({
                variantId: PLAN_VARIANTS[plan],
            });
            window.location.href = checkoutUrl;
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        <Button onClick={handleUpgrade} disabled={isLoading}>
            {isLoading ? "Loading..." : "Upgrade"}
        </Button>
    );
}
```

## Webhook Handling

### Webhook Endpoint

```typescript
// convex/http.ts
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
import crypto from "crypto";

const http = httpRouter();

http.route({
    path: "/webhooks/lemonsqueezy",
    method: "POST",
    handler: httpAction(async (ctx, req) => {
        const payload = await req.text();
        const signature = req.headers.get("x-signature");
        
        // Verify webhook signature
        const secret = process.env.LEMON_SQUEEZY_WEBHOOK_SECRET;
        const expectedSignature = crypto
            .createHmac("sha256", secret)
            .update(payload)
            .digest("hex");
        
        if (signature !== expectedSignature) {
            return new Response("Invalid signature", { status: 401 });
        }
        
        const event = JSON.parse(payload);
        
        // Handle different event types
        switch (event.meta.event_name) {
            case "subscription_created":
            case "subscription_updated":
                await ctx.runMutation(internal.billing.handleSubscriptionUpdated, {
                    data: event.data,
                });
                break;
                
            case "subscription_cancelled":
            case "subscription_expired":
                await ctx.runMutation(internal.billing.handleSubscriptionCancelled, {
                    data: event.data,
                });
                break;
                
            case "subscription_payment_success":
                await ctx.runMutation(internal.billing.handlePaymentSuccess, {
                    data: event.data,
                });
                break;
                
            case "subscription_payment_failed":
                await ctx.runMutation(internal.billing.handlePaymentFailed, {
                    data: event.data,
                });
                break;
        }
        
        return new Response("OK", { status: 200 });
    }),
});

export default http;
```

### Webhook Handlers

```typescript
// convex/billing.ts
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";

export const handleSubscriptionUpdated = internalMutation({
    args: {
        data: v.any(),
    },
    handler: async (ctx, args) => {
        const subscription = args.data;
        const attributes = subscription.attributes;
        
        // Get org ID from custom data
        const orgId = subscription.attributes?.checkout_data?.custom?.org_id;
        if (!orgId) {
            console.error("No org_id in subscription data");
            return;
        }
        
        // Parse caps from variant metadata
        const variantData = subscription.relationships?.variant?.data;
        const maxCustomers = variantData?.attributes?.metadata?.maxCustomers || 3;
        const maxStaff = variantData?.attributes?.metadata?.maxStaff || 1;
        const maxClients = variantData?.attributes?.metadata?.maxClients || 10;
        
        // Update org
        await ctx.db.patch(orgId as Id<"orgs">, {
            subscriptionId: subscription.id,
            planId: variantData?.id,
            status: attributes.status,
            maxCustomers,
            maxStaff,
            maxClients,
            trialEndsAt: attributes.trial_ends_at 
                ? new Date(attributes.trial_ends_at).getTime() 
                : undefined,
            currentPeriodStart: new Date(attributes.renews_at).getTime() - 30 * 24 * 60 * 60 * 1000,
            currentPeriodEnd: new Date(attributes.renews_at).getTime(),
            updatedAt: Date.now(),
        });
    },
});

export const handleSubscriptionCancelled = internalMutation({
    args: {
        data: v.any(),
    },
    handler: async (ctx, args) => {
        const subscription = args.data;
        const orgId = subscription.attributes?.checkout_data?.custom?.org_id;
        
        if (!orgId) return;
        
        // Downgrade to free plan
        await ctx.db.patch(orgId as Id<"orgs">, {
            status: "canceled",
            planId: undefined,
            maxCustomers: 3,  // Free tier limits
            maxStaff: 1,
            maxClients: 10,
            updatedAt: Date.now(),
        });
    },
});
```

## Usage Cap Enforcement

### Cap Checking Helpers

```typescript
// convex/lib/billing.ts
import { QueryCtx, MutationCtx } from "../_generated/server";
import { Id } from "../_generated/dataModel";

export async function getOrgLimits(ctx: QueryCtx | MutationCtx, orgId: Id<"orgs">) {
    const org = await ctx.db.get(orgId);
    if (!org) throw new Error("Organization not found");
    
    return {
        maxCustomers: org.maxCustomers,
        maxStaff: org.maxStaff,
        maxClients: org.maxClients,
        status: org.status,
        isActive: ["active", "trialing"].includes(org.status),
    };
}

export async function checkCustomerLimit(ctx: MutationCtx, orgId: Id<"orgs">) {
    const org = await ctx.db.get(orgId);
    if (!org) throw new Error("Organization not found");
    
    const count = await ctx.db
        .query("customers")
        .withIndex("by_org", (q) => q.eq("orgId", orgId))
        .collect();
    
    if (count.length >= org.maxCustomers) {
        throw new Error(
            `Customer limit reached (${org.maxCustomers}). Please upgrade your plan.`
        );
    }
}

export async function checkStaffLimit(ctx: MutationCtx, orgId: Id<"orgs">) {
    const org = await ctx.db.get(orgId);
    if (!org) throw new Error("Organization not found");
    
    const count = await ctx.db
        .query("users")
        .withIndex("by_org_role", (q) => q.eq("orgId", orgId).eq("role", "staff"))
        .collect();
    
    if (count.length >= org.maxStaff) {
        throw new Error(
            `Staff limit reached (${org.maxStaff}). Please upgrade your plan.`
        );
    }
}

export async function checkClientLimit(
    ctx: MutationCtx, 
    customerId: Id<"customers">
) {
    const customer = await ctx.db.get(customerId);
    if (!customer) throw new Error("Customer not found");
    
    const org = await ctx.db.get(customer.orgId);
    if (!org) throw new Error("Organization not found");
    
    const count = await ctx.db
        .query("users")
        .withIndex("by_customer", (q) => q.eq("customerId", customerId))
        .collect();
    
    if (count.length >= org.maxClients) {
        throw new Error(
            `Client user limit reached for this customer (${org.maxClients}). ` +
            "Please upgrade your plan."
        );
    }
}
```

### Enforce Caps in Mutations

```typescript
// convex/customers.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { checkCustomerLimit } from "./lib/billing";
import { requireRole } from "./lib/auth";

export const create = mutation({
    args: {
        name: v.string(),
        email: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const user = await requireRole(ctx, ["admin"]);
        
        // Enforce usage cap
        await checkCustomerLimit(ctx, user.orgId);
        
        return await ctx.db.insert("customers", {
            orgId: user.orgId,
            name: args.name,
            email: args.email,
            status: "active",
        });
    },
});
```

## Customer Portal

### Create Customer Portal Session

```typescript
export const createPortalSession = action({
    args: {
        orgId: v.id("orgs"),
    },
    handler: async (ctx, args) => {
        const org = await ctx.runQuery(internal.orgs.get, { orgId: args.orgId });
        if (!org?.subscriptionId) {
            throw new Error("No active subscription");
        }
        
        const response = await fetch(
            `https://api.lemonsqueezy.com/v1/subscriptions/${org.subscriptionId}/customer-portal`,
            {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${process.env.LEMON_SQUEEZY_API_KEY}`,
                    "Accept": "application/vnd.api+json",
                },
            }
        );
        
        if (!response.ok) {
            throw new Error("Failed to create portal session");
        }
        
        const { data } = await response.json();
        return { portalUrl: data.attributes.url };
    },
});
```

## Billing UI Components

### Current Plan Card

```typescript
// src/features/billing/current-plan.tsx
import { useQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { api } from "@/convex/_generated/api";
import { Card, CardHeader, CardContent } from "@/components/ui/card";

export function CurrentPlan() {
    const { data: org } = useQuery(convexQuery(api.orgs.getCurrent, {}));
    
    if (!org) return null;
    
    const isTrialing = org.status === "trialing";
    const isActive = ["active", "trialing"].includes(org.status);
    
    return (
        <Card>
            <CardHeader>
                <h3 className="text-lg font-medium">Current Plan</h3>
                <p className="text-sm text-gray-500">
                    {org.planId || "Free"}
                </p>
            </CardHeader>
            <CardContent>
                <div className="space-y-4">
                    <div className="flex justify-between">
                        <span>Status</span>
                        <span className={isActive ? "text-green-600" : "text-red-600"}>
                            {org.status}
                        </span>
                    </div>
                    
                    <div className="space-y-2">
                        <div className="flex justify-between text-sm">
                            <span>Customers</span>
                            <span>{org._customerCount} / {org.maxCustomers}</span>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-2">
                            <div 
                                className="bg-blue-600 h-2 rounded-full"
                                style={{ 
                                    width: `${(org._customerCount / org.maxCustomers) * 100}%` 
                                }}
                            />
                        </div>
                    </div>
                    
                    {isTrialing && org.trialEndsAt && (
                        <p className="text-sm text-amber-600">
                            Trial ends {new Date(org.trialEndsAt).toLocaleDateString()}
                        </p>
                    )}
                </div>
            </CardContent>
        </Card>
    );
}
```

## Graceful Degradation

When limits are reached:

1. **Show upgrade prompts** in UI
2. **Prevent new creations** with clear error messages
3. **Allow deletions** to free up space
4. **Don't break existing data** - only block new additions

```typescript
// Mutation with graceful error
export const createWithLimitCheck = mutation({
    args: { name: v.string() },
    handler: async (ctx, args) => {
        const user = await requireRole(ctx, ["admin"]);
        const org = await ctx.db.get(user.orgId);
        
        const count = await ctx.db
            .query("customers")
            .withIndex("by_org", (q) => q.eq("orgId", user.orgId))
            .collect();
        
        if (count.length >= org.maxCustomers) {
            return {
                success: false,
                error: "LIMIT_REACHED",
                limit: org.maxCustomers,
                upgradeUrl: "/billing/upgrade",
            };
        }
        
        const id = await ctx.db.insert("customers", {
            orgId: user.orgId,
            name: args.name,
        });
        
        return { success: true, id };
    },
});
```
